(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.svgPathTools = {})));
}(this, (function (exports) { 'use strict';

  // https://github.com/fontello/svgpath/blob/master/lib/path_parse.js#L4
  const paramCounts = {
    a: 7,
    c: 6,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    z: 0,
  };

  const checkValues = (command, values) => {
    const c = command.toLowerCase();
    return paramCounts.hasOwnProperty(c)
      ? values.length === paramCounts[c] || values.length % paramCounts[c] === 0
      : false
  };

  var parse = path => {
    const re = /([MmLlSsQqLlHhVvCcSsQqTtAaZz])([^MmLlSsQqLlHhVvCcSsQqTtAaZz]*)/g;
    const num = /-?[0-9]*\.?\d+/g;
    const results = [];
    path.replace(re, (match, command, params) => {
      const values = params.match(num) || [];
      if (checkValues(command, values)) {
        results.push({ command, values: values.map(v => +v) });
      } else {
        console.log(
          `
⚠️  Command ${command} passed with invalid params length ${
          values.length
        } instead of ${paramCounts[command]}, ignored.
`
        );
      }
    });
    return results
  }

  var stringify = path => {
    return path.reduce((acc, next) => {
      return `${acc}${next['command']}${next['values'].join(' ')}`
    }, '')
  }

  const chunkArray = (arr, size = 2) => {
    let results = [];
    while (arr.length) {
      results.push(arr.splice(0, size));
    }
    return results
  };

  var scale = (path, { scale = 1, scaleY, round = 3 } = {}) => {
    const doValue = val => (round ? +val.toFixed(round) : val);
    const _x = scale;
    const _y = scaleY || scale;

    return path.map(({ command, values }) => {
      const c = command.toLowerCase();
      if (c === 'v' || c === 'h') {
        const [val] = values;
        return {
          command,
          values: [doValue(val * (c === 'v' ? _y : _x))],
        }
      }

      if (c === 'a') {
        const chunked = chunkArray(values, 7);
        const v = chunked.reduce((acc, next) => {
          const [rx, ry, xAxisRotation, largeArcFlag, sweepFLag, x, y] = next;
          return [
            ...acc,
            doValue(rx * _x),
            doValue(ry * _y),
            xAxisRotation,
            largeArcFlag,
            sweepFLag,
            doValue(x * _x),
            doValue(y * _y),
          ]
        }, []);

        return {
          command,
          values: v,
        }
      }

      return {
        command,
        values: values.map((val, i) => {
          return doValue((val *= i % 2 ? _x : _y))
        }),
      }
    })
  }

  const scalePath = (path, options) => {
    const parsed = parse(path);
    const scaled = scale(parsed, options);
    return stringify(scaled)
  };

  exports.parse = parse;
  exports.stringify = stringify;
  exports.scale = scale;
  exports.scalePath = scalePath;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
